#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fiddle'
require 'fiddle/import'

module Libc
  extend Fiddle::Importer
  dlload Fiddle::Handle::DEFAULT
  extern 'char* strerror(int)'
end

HEADER_TEXT = <<-HEADER_TEXT
-- clair-error.ads
-- Copyright (c) 2025 Hodong Kim <hodong@nimfsoft.art>
--
-- Permission to use, copy, modify, and/or distribute this software for any
-- purpose with or without fee is hereby granted.
--
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
--
-- THIS FILE IS AUTOMATICALLY GENERATED.
-- DO NOT EDIT THIS FILE MANUALLY.

with Interfaces.C;

package Clair.Error is
  --
  -- System Error to Ada Exception Mapping
  --
  -- Provides exceptions for common errno values found on major operating
  -- systems. This includes standardized POSIX errors and various
  -- platform-specific extensions (e.g., from FreeBSD, Linux).
  --
  -- The exception names are derived from the descriptions in the
  -- strerror(3) and errno(2) man pages.
  --
  -- NOTE: This list is not exhaustive. The presence of a specific error
  --       is not guaranteed on all systems. POSIX-defined errors are
  --       generally portable, but platform-specific ones are not.
  --
HEADER_TEXT

FOOTER_TEXT = <<-FOOTER_TEXT

  -- For errno values not explicitly mapped to a specific exception.
  Unmapped_Error : exception;

  function get_errno return Interfaces.C.int;
  pragma import (c, get_errno, "clair_error_get_errno");

  function get_error_message (errno_code : Interfaces.C.int) return String;
  function format_posix_error_message (errno_code    : in Interfaces.C.int;
                                       function_name : in String;
                                       context_info  : in String) return String;
end Clair.Error;
FOOTER_TEXT

map = {
  "EPERM"           => "Operation_Not_Permitted",
  "ENOENT"          => "No_Such_File_Or_Directory",
  "ESRCH"           => "No_Such_Process",
  "EINTR"           => "Interrupted_System_Call",
  "EIO"             => "Input_Output_Error",
  "ENXIO"           => "Device_Not_Configured",
  "E2BIG"           => "Argument_List_Too_Long",
  "ENOEXEC"         => "Exec_Format_Error",
  "EBADF"           => "Bad_File_Descriptor",
  "ECHILD"          => "No_Child_Processes",
  "EDEADLK"         => "Resource_Deadlock_Avoided",
  "ENOMEM"          => "Cannot_Allocate_Memory",
  "EACCES"          => "Permission_Denied",
  "EFAULT"          => "Bad_Address",
  "ENOTBLK"         => "Block_Device_Required",
  "EBUSY"           => "Device_Busy",
  "EEXIST"          => "File_Exists",
  "EXDEV"           => "Cross_Device_Link",
  "ENODEV"          => "Operation_Not_Supported_By_Device",
  "ENOTDIR"         => "Not_A_Directory",
  "EISDIR"          => "Is_A_Directory",
  "EINVAL"          => "Invalid_Argument",
  "ENFILE"          => "Too_Many_Open_Files_In_System",
  "EMFILE"          => "Too_Many_Open_Files",
  "ENOTTY"          => "Inappropriate_Ioctl_For_Device",
  "ETXTBSY"         => "Text_File_Busy",
  "EFBIG"           => "File_Too_Large",
  "ENOSPC"          => "No_Space_Left_On_Device",
  "ESPIPE"          => "Illegal_Seek",
  "EROFS"           => "Read_Only_File_System",
  "EMLINK"          => "Too_Many_Links",
  "EPIPE"           => "Broken_Pipe",
  "EDOM"            => "Numerical_Argument_Out_Of_Domain",
  "ERANGE"          => "Result_Too_Large",
  "EAGAIN"          => "Resource_Temporarily_Unavailable",
  "EINPROGRESS"     => "Operation_Now_In_Progress",
  "EALREADY"        => "Operation_Already_In_Progress",
  "ENOTSOCK"        => "Socket_Operation_On_Non_Socket",
  "EDESTADDRREQ"    => "Destination_Address_Required",
  "EMSGSIZE"        => "Message_Too_Long",
  "EPROTOTYPE"      => "Protocol_Wrong_Type_For_Socket",
  "ENOPROTOOPT"     => "Protocol_Not_Available",
  "EPROTONOSUPPORT" => "Protocol_Not_Supported",
  "ESOCKTNOSUPPORT" => "Socket_Type_Not_Supported",
  "EOPNOTSUPP"      => "Operation_Not_Supported",
  "EPFNOSUPPORT"    => "Protocol_Family_Not_Supported",
  "EAFNOSUPPORT"    => "Address_Family_Not_Supported",
  "EADDRINUSE"      => "Address_Already_In_Use",
  "EADDRNOTAVAIL"   => "Cannot_Assign_Requested_Address",
  "ENETDOWN"        => "Network_Is_Down",
  "ENETUNREACH"     => "Network_Is_Unreachable",
  "ENETRESET"       => "Network_Dropped_Connection_On_Reset",
  "ECONNABORTED"    => "Software_Caused_Connection_Abort",
  "ECONNRESET"      => "Connection_Reset_By_Peer",
  "ENOBUFS"         => "No_Buffer_Space_Available",
  "EISCONN"         => "Socket_Is_Already_Connected",
  "ENOTCONN"        => "Socket_Is_Not_Connected",
  "ESHUTDOWN"       => "Cannot_Send_After_Socket_Shutdown",
  "ETOOMANYREFS"    => "Too_Many_References",
  "ETIMEDOUT"       => "Operation_Timed_Out",
  "ECONNREFUSED"    => "Connection_Refused",
  "ELOOP"           => "Too_Many_Levels_Of_Symbolic_Links",
  "ENAMETOOLONG"    => "File_Name_Too_Long",
  "EHOSTDOWN"       => "Host_Is_Down",
  "EHOSTUNREACH"    => "No_Route_To_Host",
  "ENOTEMPTY"       => "Directory_Not_Empty",
  "EPROCLIM"        => "Too_Many_Processes",
  "EUSERS"          => "Too_Many_Users",
  "EDQUOT"          => "Disc_Quota_Exceeded",
  "ESTALE"          => "Stale_Nfs_File_Handle",
  "ERPCMISMATCH"    => "Rpc_Version_Wrong",
  "EPROGUNAVAIL"    => "Rpc_Prog_Not_Avail",
  "EPROGMISMATCH"   => "Program_Version_Wrong",
  "EPROCUNAVAIL"    => "Bad_Procedure_For_Program",
  "ENOLCK"          => "No_Locks_Available",
  "ENOSYS"          => "Function_Not_Implemented",
  "EFTYPE"          => "Inappropriate_File_Type_Or_Format",
  "EAUTH"           => "Authentication_Error",
  "ENEEDAUTH"       => "Need_Authenticator",
  "EIDRM"           => "Identifier_Removed",
  "ENOMSG"          => "No_Message_Of_Desired_Type",
  "EOVERFLOW"       => "Value_Too_Large_To_Be_Stored_In_Data_Type",
  "ECANCELED"       => "Operation_Canceled",
  "EILSEQ"          => "Illegal_Byte_Sequence",
  "ENOATTR"         => "Attribute_Not_Found",
  "EDOOFUS"         => "Programming_Error",
  "EBADMSG"         => "Bad_Message",
  "EMULTIHOP"       => "Multihop_Attempted",
  "ENOLINK"         => "Link_Has_Been_Severed",
  "EPROTO"          => "Protocol_Error",
  "ENOTCAPABLE"     => "Capabilities_Insufficient",
  "ECAPMODE"        => "Not_Permitted_In_Capability_Mode",
  "ENOTRECOVERABLE" => "State_Not_Recoverable",
  "EOWNERDEAD"      => "Previous_Owner_Died",
  "EINTEGRITY"      => "Integrity_Check_Failed",
}

puts HEADER_TEXT

map.each_pair do |errno_name, exception|
  printf("  %-41s : exception; -- %s\n", exception, errno_name)
end

COMMENTS = <<-COMMENTS
  --
  -- System Error Code Constants
  --
  -- This section defines constants for system error codes (errno). The values
  -- and descriptions are based on a reference POSIX-compliant system (e.g.,
  -- FreeBSD) to provide a consistent set of common error numbers.
  --
  -- These constants allow C-level error codes to be referenced by name
  -- within Ada code, improving readability and maintainability.
  --
  -- NOTE: While the constant names are largely standardized by POSIX, their
  --       integer values can vary between operating systems. This list
  --       provides a stable baseline but is not universally portable.
  --
COMMENTS

puts COMMENTS

map.each_pair do |errno_name, exception|
  begin
    errno_class = Errno.const_get(errno_name)
    error_value = errno_class::Errno
    error_msg   = Libc.strerror(error_value)

    if error_msg.to_s == "Address family not supported by protocol family"
      error_msg = "Address family not supported"
    end

    printf("  %-15s : constant := %2s; -- %s\n",
           errno_name, error_value, error_msg)

  rescue NameError
    host_os = RbConfig::CONFIG['host_os']
    # Ruby bug
    if errno_name == "EINTEGRITY" and /freebsd/i.match?(host_os)
      printf("  %-15s : constant := 97; -- Integrity check failed\n",
             errno_name)
    else
      puts "âŒ Error: The constant #{errno_name} is not defined on this system."
      exit 1
    end
  end
end

puts FOOTER_TEXT
