#include <stdio.h>
#include <inttypes.h>
#include <fcntl.h>

const char* header = R"(-- clair-file.ads
-- Copyright (c) 2025 Hodong Kim <hodong@nimfsoft.art>
--
-- Permission to use, copy, modify, and/or distribute this software for any
-- purpose with or without fee is hereby granted.
--
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
--
-- THIS FILE IS AUTOMATICALLY GENERATED.
-- DO NOT EDIT THIS FILE MANUALLY.

with Interfaces.C;
with Clair.Types;
with System.Storage_Elements;

package Clair.File is

  type Descriptor is new Interfaces.C.int;
  type Flags      is new Interfaces.C.int;

  type Pipe_Ends is record
    read_end  : Descriptor;
    write_end : Descriptor;
  end record;

  -- flags for open(2))";

const char* footer = R"(
  STDIN_FILENO  : constant := 0;
  STDOUT_FILENO : constant := 1;
  STDERR_FILENO : constant := 2;

  -- "Constructor" role for the open functions
  function open (path  : String;
                 flags : File.Flags) return Descriptor;
  function open (path  : String;
                 flags : File.Flags;
                 mode  : Clair.Types.mode_t) return Descriptor;

  procedure close (fd : in Descriptor);

  function read (fd     : in Descriptor;
                 buffer : in out System.Storage_Elements.Storage_Array)
  return Natural;

  function write (fd     : in Descriptor;
                  buffer : in System.Storage_Elements.Storage_Array)
  return Natural;

  function c_read (fd      : in     Descriptor;
                   buffer  : in out Interfaces.C.char_array;
                   n_bytes : Interfaces.C.size_t) return Clair.Types.ssize_t;
  pragma import (c, c_read, "read");

  function c_write (fd      : in Descriptor;
                    buffer  : in Interfaces.C.char_array;
                    n_bytes : Interfaces.C.size_t) return Clair.Types.ssize_t;
  pragma import (c, c_write, "write");

  function pipe return Pipe_Ends;

  function duplicate    (fd : in Descriptor) return Descriptor;
  function duplicate_to (fd     : in Descriptor;
                         new_fd : in File.Descriptor) return Descriptor;
  -- The umask() system call is always successful.
  function umask (new_mask : Clair.Types.mode_t) return Clair.Types.mode_t;

end Clair.File;)";

int main ()
{
  puts (header);
  printf ("  O_RDONLY    : constant := %u;\n", O_RDONLY);
  printf ("  O_WRONLY    : constant := %u;\n", O_WRONLY);
  printf ("  O_RDWR      : constant := %u;\n", O_RDWR);
  printf ("  O_ACCMODE   : constant := %u;\n", O_ACCMODE);
  printf ("  O_NONBLOCK  : constant := %u;\n", O_NONBLOCK);
  printf ("  O_APPEND    : constant := %u;\n", O_APPEND);
  printf ("  O_SYNC      : constant := %u;\n", O_SYNC);
  printf ("  O_NOFOLLOW  : constant := %u;\n", O_NOFOLLOW);
  printf ("  O_CREAT     : constant := %u;\n", O_CREAT);
  printf ("  O_TRUNC     : constant := %u;\n", O_TRUNC);
  printf ("  O_EXCL      : constant := %u;\n", O_EXCL);
  printf ("  O_NOCTTY    : constant := %u;\n", O_NOCTTY);
  printf ("  O_DIRECTORY : constant := %u;\n", O_DIRECTORY);
  printf ("  O_EXEC      : constant := %u;\n", O_EXEC);
  printf ("  O_TTY_INIT  : constant := %u;\n", O_TTY_INIT);
  printf ("  O_CLOEXEC   : constant := %u;\n", O_CLOEXEC);
  printf ("  O_DSYNC     : constant := %u;\n", O_DSYNC);
  puts (footer);
  return 0;
}
