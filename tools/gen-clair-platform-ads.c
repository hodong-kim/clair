/*
 * gen-clair-log-platform-ads.c
 * Copyright (C) 2025,2026 Hodong Kim <hodong@nimfsoft.art>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <stdint.h>
#include <errno.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <dlfcn.h>
#include <syslog.h>
#include <signal.h>
#include <locale.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/event.h>
#include <sys/socket.h>
#include <sys/file.h>
#include <sys/un.h>
#include <inttypes.h>

#include "clair-errno-map.h"

/* * Helper Macros
 */
#define GET_ADA_TYPE_NAME(X)  _Generic((X), \
  char:               "Interfaces.C.char", \
  signed char:        "Interfaces.C.signed_char", \
  unsigned char:      "Interfaces.C.unsigned_char", \
  short:              "Interfaces.C.short", \
  unsigned short:     "Interfaces.C.unsigned_short", \
  int:                "Interfaces.C.int", \
  unsigned int:       "Interfaces.C.unsigned", \
  long:               "Interfaces.C.long", \
  unsigned long:      "Interfaces.C.unsigned_long", \
  long long:          "Interfaces.C.long_long", \
  unsigned long long: "Interfaces.C.unsigned_long_long", \
  default:            "other" \
)

#define ARRAY_SIZE(x)  (sizeof(x) / sizeof((x)[0]))

/* * Header & Footer
 */
const char* header = R"(-- clair-platform.ads
-- Copyright (c) 2025,2026 Hodong Kim <hodong@nimfsoft.art>
--
-- Permission to use, copy, modify, and/or distribute this software for any
-- purpose with or without fee is hereby granted.
--
-- THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-- WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-- MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-- ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-- WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-- ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-- OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
--
-- THIS FILE IS AUTOMATICALLY GENERATED.
-- DO NOT EDIT THIS FILE MANUALLY.
--
package Clair.Platform is
  pragma preelaborate;
)";

const char* footer = R"(
end Clair.Platform;)";

/*
 * Data Structures
 */
struct type_entry {
  const char* c_name;
  const char* ada_type;
};

// Generic structure for integer constants
struct int_const {
  const char* name;
  int64_t     value; // Use int64_t to safely hold int, long, etc.
};

// Structure for size/offset constants
struct size_const {
  const char* name;
  size_t      value;
};

// Structure for pointer/hex constants
struct hex_const {
  const char* name;
  uintptr_t   value;
};

/*
 * Global Data Definitions (All static const)
 */

// 1. System Types
static const struct type_entry system_types[] = {
  { "uintptr_t",   GET_ADA_TYPE_NAME ((uintptr_t)   0) },
  { "int64_t",     GET_ADA_TYPE_NAME ((int64_t)     0) },
  { "uint64_t",    GET_ADA_TYPE_NAME ((uint64_t)    0) },
  { "mode_t",      GET_ADA_TYPE_NAME ((mode_t)      0) },
  { "pid_t",       GET_ADA_TYPE_NAME ((pid_t)       0) },
  { "ssize_t",     GET_ADA_TYPE_NAME ((ssize_t)     0) },
  { "off_t",       GET_ADA_TYPE_NAME ((off_t)       0) },
  { "socklen_t",   GET_ADA_TYPE_NAME ((socklen_t)   0) },
  { "time_t",      GET_ADA_TYPE_NAME ((time_t)      0) },
  { "sa_family_t", GET_ADA_TYPE_NAME ((sa_family_t) 0) }
};

// 2. dlfcn.h (Flags -> HEX)
static const struct int_const dlfcn_consts[] = {
  { "RTLD_LAZY",   RTLD_LAZY   },
  { "RTLD_NOW",    RTLD_NOW    },
  { "RTLD_LOCAL",  RTLD_LOCAL  },
  { "RTLD_GLOBAL", RTLD_GLOBAL }
};

// 3. syslog.h (Levels -> Decimal)
static const struct int_const syslog_consts[] = {
  { "LOG_PID",    LOG_PID    },
  { "LOG_CONS",   LOG_CONS   },
  { "LOG_NDELAY", LOG_NDELAY },
  { "LOG_PERROR", LOG_PERROR },
  { "LOG_ODELAY", LOG_ODELAY },
  { "LOG_NOWAIT", LOG_NOWAIT }
};

// 4. signal.h (Numbers -> Decimal, Pointers -> Hex, Sizes -> Decimal)
static const struct int_const signal_ints[] = {
  { "SIGINT",       SIGINT       },
  { "SIGTERM",      SIGTERM      },
  { "SIGTSTP",      SIGTSTP      },
  { "SIGCHLD",      SIGCHLD      },
  { "SIG_BLOCK",    SIG_BLOCK    },
  { "SIG_UNBLOCK",  SIG_UNBLOCK  },
  { "SIG_SETMASK",  SIG_SETMASK  },
  { "SA_NOCLDWAIT", SA_NOCLDWAIT }
};

static const struct hex_const signal_hexs[] = {
  { "SIG_DFL", (uintptr_t) SIG_DFL },
  { "SIG_IGN", (uintptr_t) SIG_IGN }
};

static const struct size_const signal_sizes[] = {
  { "SIZE_OF_SIGACTION",        sizeof   (struct sigaction)             },
  { "SIZE_OF_SIGSET",           sizeof   (sigset_t)                     },
  { "SIGACTION_SIZE",           sizeof   (struct sigaction)             },
  { "SIGACTION_ALIGNMENT",      _Alignof (struct sigaction)             },
  { "SIGACTION_HANDLER_OFFSET", offsetof (struct sigaction, sa_handler) },
  { "SIGACTION_FLAGS_OFFSET",   offsetof (struct sigaction, sa_flags)   },
  { "SIGACTION_MASK_OFFSET",    offsetof (struct sigaction, sa_mask)    }
};

// 5. sys/event.h (Flags -> Decimal/Hex mixed, Sizes -> Decimal)
// NOTE_MSECONDS is a value, usually decimal. KQUEUE_CLOEXEC is a flag, maybe hex?
// Let's keep these decimal as they are small integers, unless requested otherwise.
static const struct int_const kevent_ints[] = {
  { "NOTE_MSECONDS",  NOTE_MSECONDS  },
  { "KQUEUE_CLOEXEC", KQUEUE_CLOEXEC }
};

static const struct size_const kevent_sizes[] = {
  { "KEVENT_SIZE",          sizeof   (struct kevent)         },
  { "KEVENT_ALIGNMENT",     _Alignof (struct kevent)         },
  { "KEVENT_IDENT_OFFSET",  offsetof (struct kevent, ident)  },
  { "KEVENT_FILTER_OFFSET", offsetof (struct kevent, filter) },
  { "KEVENT_FLAGS_OFFSET",  offsetof (struct kevent, flags)  },
  { "KEVENT_FFLAGS_OFFSET", offsetof (struct kevent, fflags) },
  { "KEVENT_DATA_OFFSET",   offsetof (struct kevent, data)   },
  { "KEVENT_UDATA_OFFSET",  offsetof (struct kevent, udata)  },
  { "KEVENT_EXT_OFFSET",    offsetof (struct kevent, ext)    }
};

// 6. unistd.h (FDs -> Decimal)
static const struct int_const unistd_consts[] = {
  { "STDIN_FILENO",  STDIN_FILENO  },
  { "STDOUT_FILENO", STDOUT_FILENO },
  { "STDERR_FILENO", STDERR_FILENO }
};

// 7. fcntl.h (Flags -> HEX)
static const struct int_const fcntl_flags[] = {
  { "O_RDONLY",    O_RDONLY    },
  { "O_WRONLY",    O_WRONLY    },
  { "O_RDWR",      O_RDWR      },
  { "O_ACCMODE",   O_ACCMODE   },
  { "O_NONBLOCK",  O_NONBLOCK  },
  { "O_APPEND",    O_APPEND    },
  { "O_SYNC",      O_SYNC      },
  { "O_NOFOLLOW",  O_NOFOLLOW  },
  { "O_CREAT",     O_CREAT     },
  { "O_TRUNC",     O_TRUNC     },
  { "O_EXCL",      O_EXCL      },
  { "O_NOCTTY",    O_NOCTTY    },
  { "O_DIRECTORY", O_DIRECTORY },
  { "O_EXEC",      O_EXEC      },
  { "O_TTY_INIT",  O_TTY_INIT  },
  { "O_CLOEXEC",   O_CLOEXEC   },
  { "O_DSYNC",     O_DSYNC     }
};

static const struct int_const fcntl_cmds[] = {
  { "F_DUPFD",     F_DUPFD    },
  { "F_GETFD",     F_GETFD    },
  { "F_SETFD",     F_SETFD    },
  { "F_GETFL",     F_GETFL    },
  { "F_SETFL",     F_SETFL    },
  { "F_GETOWN",    F_GETOWN   },
  { "F_SETOWN",    F_SETOWN   },
  { "F_RDLCK",     F_RDLCK    },
  { "F_WRLCK",     F_WRLCK    },
  { "F_UNLCK",     F_UNLCK    },
  { "F_SETLK",     F_SETLK    },
  { "F_SETLKW",    F_SETLKW   },
  { "FD_CLOEXEC",  FD_CLOEXEC }
};

// 8. sys/file.h (Flock -> HEX)
static const struct int_const flock_consts[] = {
  { "LOCK_SH", LOCK_SH },
  { "LOCK_EX", LOCK_EX },
  { "LOCK_NB", LOCK_NB },
  { "LOCK_UN", LOCK_UN }
};

// 9. sys/socket.h (Flags/Types -> HEX)
static const struct int_const socket_consts[] = {
  { "AF_UNIX",       AF_UNIX       },
  { "SOCK_STREAM",   SOCK_STREAM   },
  { "SOCK_CLOEXEC",  SOCK_CLOEXEC  },
  { "SOCK_CLOFORK",  SOCK_CLOFORK  },
  { "SOCK_NONBLOCK", SOCK_NONBLOCK },
  { "MSG_OOB",       MSG_OOB       },
  { "MSG_DONTROUTE", MSG_DONTROUTE },
  { "MSG_EOR",       MSG_EOR       },
  { "MSG_DONTWAIT",  MSG_DONTWAIT  },
  { "MSG_EOF",       MSG_EOF       },
  { "MSG_NOSIGNAL",  MSG_NOSIGNAL  }
};

// 10. Poll (Offsets -> Decimal, Flags -> HEX)
static const struct size_const poll_sizes[] = {
  { "POLLFD_SIZE",           sizeof   (struct pollfd)          },
  { "POLLFD_ALIGNMENT",      _Alignof (struct pollfd)          },
  { "POLLFD_FD_OFFSET",      offsetof (struct pollfd, fd)      },
  { "POLLFD_EVENTS_OFFSET",  offsetof (struct pollfd, events)  },
  { "POLLFD_REVENTS_OFFSET", offsetof (struct pollfd, revents) }
};

static const struct hex_const poll_flags[] = {
  { "POLLIN",   POLLIN   },
  { "POLLOUT",  POLLOUT  },
  { "POLLERR",  POLLERR  },
  { "POLLHUP",  POLLHUP  },
  { "POLLNVAL", POLLNVAL }
};

// 11. Locale (Indices -> Decimal)
static const struct int_const locale_consts[] = {
  { "LC_ALL",      LC_ALL      },
  { "LC_CTYPE",    LC_CTYPE    },
  { "LC_NUMERIC",  LC_NUMERIC  },
  { "LC_TIME",     LC_TIME     },
  { "LC_COLLATE",  LC_COLLATE  },
  { "LC_MONETARY", LC_MONETARY },
  { "LC_MESSAGES", LC_MESSAGES }
};

// 12. Time (Values -> Decimal)
static const struct int_const time_ints[] = {
  { "CLOCK_MONOTONIC", CLOCK_MONOTONIC }
};

static const struct size_const time_sizes[] = {
  { "TIMESPEC_SEC_OFFSET",  offsetof (struct timespec, tv_sec)  },
  { "TIMESPEC_NSEC_OFFSET", offsetof (struct timespec, tv_nsec) },
  { "TIMESPEC_SIZE",        sizeof   (struct timespec)          },
  { "TIMESPEC_ALIGNMENT",   _Alignof (struct timespec)          }
};

// 13. Sockaddr_Un (Offsets/Sizes -> Decimal)
static const struct size_const sockaddr_un_sizes[] = {
  { "SOCKADDR_UN_SIZE",              sizeof  (struct sockaddr_un)             },
  { "SOCKADDR_UN_ALIGNMENT",         _Alignof(struct sockaddr_un)             },
  { "SOCKADDR_UN_SUN_FAMILY_OFFSET", offsetof(struct sockaddr_un, sun_family) },
  { "SOCKADDR_UN_SUN_PATH_OFFSET",   offsetof(struct sockaddr_un, sun_path)   },
  { "SOCKADDR_UN_PATH_LENGTH", sizeof (((struct sockaddr_un*) 0)->sun_path)   }
};

/*
 * Alignment Logic
 */
static void update_max_len (const char* name, int* max_len)
{
  int len = (int) strlen (name);
  if (len > *max_len)
    *max_len = len;
}

// Macro to iterate arrays and update max_len
#define UPDATE_GLOBAL_MAX(arr) \
  for (size_t i = 0; i < ARRAY_SIZE (arr); i++) \
    update_max_len (arr[i].name, &global_max_len)

/*
 * Printing Functions
 */

void print_system_types ()
{
  int max_len = 0;
  // Types have their own alignment separate from constants
  for (size_t i = 0; i < ARRAY_SIZE (system_types); i++)
    update_max_len (system_types[i].c_name, &max_len);

  puts ("  -- system types");

  for (size_t i = 0; i < ARRAY_SIZE (system_types); i++)
  {
    printf ("  type %-*s is new %s;\n",
            max_len,
            system_types[i].c_name,
            system_types[i].ada_type);
  }
}

// NOTE: All constant printing functions now take 'alignment' argument
void print_dlfcn_constants (int alignment)
{
  puts ("  -- dlfcn.h");

  for (size_t i = 0; i < ARRAY_SIZE (dlfcn_consts); i++)
  {
    printf ("  %-*s : constant := 16#%" PRIX64 "#;\n",
            alignment,
            dlfcn_consts[i].name,
            (uint64_t) dlfcn_consts[i].value);
  }
}

void print_syslog_constants (int alignment)
{
  puts ("  -- syslog.h");

  for (size_t i = 0; i < ARRAY_SIZE (syslog_consts); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            syslog_consts[i].name,
            syslog_consts[i].value);
  }
}

void print_signal_constants (int alignment)
{
  puts ("  -- signal.h");

  for (size_t i = 0; i < ARRAY_SIZE (signal_ints); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            signal_ints[i].name,
            signal_ints[i].value);
  }

  for (size_t i = 0; i < ARRAY_SIZE (signal_hexs); i++)
  {
    printf ("  %-*s : constant := 16#%jX#;\n",
            alignment,
            signal_hexs[i].name,
            (uintmax_t) signal_hexs[i].value);
  }

  for (size_t i = 0; i < ARRAY_SIZE (signal_sizes); i++)
  {
    printf ("  %-*s : constant := %zu;\n",
            alignment,
            signal_sizes[i].name,
            signal_sizes[i].value);
  }
}

void print_errno_constants (int alignment)
{
  puts ("  -- errno.h");

  size_t count = sizeof (errno_map) / sizeof (errno_map[0]);

  for (size_t i = 0; i < count; i++)
  {
    printf ("  %-*s : constant := %d;\n",
            alignment,
            errno_map[i].name,
            errno_map[i].value);
  }
}

void print_kevent_constants (int alignment)
{
  puts ("  -- sys/event.h");

  for (size_t i = 0; i < ARRAY_SIZE (kevent_ints); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            kevent_ints[i].name,
            kevent_ints[i].value);
  }

  for (size_t i = 0; i < ARRAY_SIZE (kevent_sizes); i++)
  {
    printf ("  %-*s : constant := %zu;\n",
            alignment,
            kevent_sizes[i].name,
            kevent_sizes[i].value);
  }
}

void print_unistd_constants (int alignment)
{
  puts ("  -- unistd.h");

  for (size_t i = 0; i < ARRAY_SIZE (unistd_consts); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            unistd_consts[i].name,
            unistd_consts[i].value);
  }
}

void print_fcntl_constants (int alignment)
{
  puts ("  -- fcntl.h");

  for (size_t i = 0; i < ARRAY_SIZE (fcntl_flags); i++)
  {
    printf ("  %-*s : constant := 16#%" PRIX64 "#;\n",
            alignment,
            fcntl_flags[i].name,
            (uint64_t) fcntl_flags[i].value);
  }

  puts ("  -- fcntl commands");

  for (size_t i = 0; i < ARRAY_SIZE (fcntl_cmds); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            fcntl_cmds[i].name,
            fcntl_cmds[i].value);
  }
}

void print_flock_constants (int alignment)
{
  puts ("  -- sys/file.h (flock constants)");

  for (size_t i = 0; i < ARRAY_SIZE (flock_consts); i++)
  {
    printf ("  %-*s : constant := 16#%" PRIX64 "#;\n",
            alignment,
            flock_consts[i].name,
            (uint64_t) flock_consts[i].value);
  }
}

void print_socket_constants (int alignment)
{
  puts ("  -- #include  <sys/socket.h>");

  for (size_t i = 0; i < ARRAY_SIZE (socket_consts); i++)
  {
    printf ("  %-*s : constant := 16#%" PRIX64 "#;\n",
            alignment,
            socket_consts[i].name,
            (uint64_t) socket_consts[i].value);
  }
}

void print_poll_constants (int alignment)
{
  puts ("  -- pollfd layout info");

  for (size_t i = 0; i < ARRAY_SIZE (poll_sizes); i++)
  {
    printf ("  %-*s : constant := %zu;\n",
            alignment,
            poll_sizes[i].name,
            poll_sizes[i].value);
  }

  for (size_t i = 0; i < ARRAY_SIZE (poll_flags); i++)
  {
    printf ("  %-*s : constant := 16#%jX#;\n",
            alignment,
            poll_flags[i].name,
            (uintmax_t) poll_flags[i].value);
  }
}

void print_locale_constants (int alignment)
{
  puts ("  -- locale.h");

  for (size_t i = 0; i < ARRAY_SIZE (locale_consts); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            locale_consts[i].name,
            locale_consts[i].value);
  }
}

void print_time_constants (int alignment)
{
  puts ("  -- time.h");

  for (size_t i = 0; i < ARRAY_SIZE (time_ints); i++)
  {
    printf ("  %-*s : constant := %" PRId64 ";\n",
            alignment,
            time_ints[i].name,
            time_ints[i].value);
  }

  for (size_t i = 0; i < ARRAY_SIZE (time_sizes); i++)
  {
    printf ("  %-*s : constant := %zu;\n",
            alignment,
            time_sizes[i].name,
            time_sizes[i].value);
  }
}

void print_sockaddr_un_info (int alignment)
{
  puts ("  -- sockaddr_un");

  for (size_t i = 0; i < ARRAY_SIZE (sockaddr_un_sizes); i++)
  {
    printf ("  %-*s : constant := %zu;\n",
            alignment, sockaddr_un_sizes[i].name, sockaddr_un_sizes[i].value);
  }
}

int main ()
{
  puts (header);

  // 1. Print Types (Independent Alignment)
  print_system_types ();

  // 2. Calculate Global Alignment for ALL Constants
  int global_max_len = 0;

  UPDATE_GLOBAL_MAX (dlfcn_consts);
  UPDATE_GLOBAL_MAX (syslog_consts);
  UPDATE_GLOBAL_MAX (signal_ints);
  UPDATE_GLOBAL_MAX (signal_hexs);
  UPDATE_GLOBAL_MAX (signal_sizes);

  // Errno map
  size_t errno_count = sizeof (errno_map) / sizeof (errno_map[0]);
  for (size_t i = 0; i < errno_count; i++)
    update_max_len (errno_map[i].name, &global_max_len);

  UPDATE_GLOBAL_MAX (kevent_ints);
  UPDATE_GLOBAL_MAX (kevent_sizes);
  UPDATE_GLOBAL_MAX (unistd_consts);
  UPDATE_GLOBAL_MAX (fcntl_flags);
  UPDATE_GLOBAL_MAX (fcntl_cmds);
  UPDATE_GLOBAL_MAX (flock_consts);
  UPDATE_GLOBAL_MAX (socket_consts);
  UPDATE_GLOBAL_MAX (poll_sizes);
  UPDATE_GLOBAL_MAX (poll_flags);
  UPDATE_GLOBAL_MAX (locale_consts);
  UPDATE_GLOBAL_MAX (time_ints);
  UPDATE_GLOBAL_MAX (time_sizes);
  UPDATE_GLOBAL_MAX (sockaddr_un_sizes);

  // 3. Print Constants with Global Alignment
  print_dlfcn_constants  (global_max_len);
  print_syslog_constants (global_max_len);
  print_signal_constants (global_max_len);
  print_errno_constants  (global_max_len);
  print_kevent_constants (global_max_len);
  print_unistd_constants (global_max_len);
  print_fcntl_constants  (global_max_len);
  print_flock_constants  (global_max_len);
  print_socket_constants (global_max_len);
  print_poll_constants   (global_max_len);
  print_locale_constants (global_max_len);
  print_time_constants   (global_max_len);
  print_sockaddr_un_info (global_max_len);

  puts (footer);

  return 0;
}
