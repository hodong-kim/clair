/*
 * test-clair-c-api.c
 * Copyright (C) 2025,2026 Hodong Kim <hodong@nimfsoft.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdbool.h>
#include "clair.h"
#include <errno.h>
#include <string.h>

/* Ada runtime functions generated by the binder */
extern void adainit  (void);
extern void adafinal (void);

/* Context structure to avoid global variables */
typedef struct {
    clair_event_loop_t* loop;
    int tick_count;
    int max_ticks;
} AppContext;

/* 1. Timer Callback: Executed every 1000ms */
void on_timer_tick (clair_event_source_t* timer, void* user_data)
{
  AppContext* ctx = (AppContext*) user_data;
  ctx->tick_count++;

  printf("[Timer] Tick #%d/%d\n", ctx->tick_count, ctx->max_ticks);

  if (ctx->tick_count >= ctx->max_ticks)
  {
    printf("[Timer] Limit reached. Quitting loop...\n");
    clair_event_loop_quit(ctx->loop);
  }
}

/* 2. Stdin Watcher Callback */
void on_stdin_readable (clair_event_source_t* io,
                        clair_fd_t            fd,
                        clair_event_mask_t    events,
                        void*                 user_data)
{
    char buf[1024];
    ssize_t n = read(fd, buf, sizeof(buf) - 1);

    if (n > 0) {
        buf[n] = '\0';
        // Remove trailing newline for cleaner output
        if (buf[n - 1] == '\n') buf[n - 1] = '\0';
        printf("[Stdin] Input detected: [%s]\n", buf);
    } else if (n == 0) {
        printf("[Stdin] EOF detected. Removing watch.\n");
        // In a real app, you might want to remove this source here
    }
}

int main(void)
{
  AppContext ctx = {
      .loop = NULL,
      .tick_count = 0,
      .max_ticks = 5
  };

  int result = EXIT_FAILURE;

  /* Initialization: Ada Runtime & Elaboration */
  adainit();

  /* Create Event Loop */
  ctx.loop = clair_event_loop_create();
  if (!ctx.loop) {
      fprintf (stderr, "Fatal: Failed to create Clair event loop\n");
      goto cleanup_ada;
  }

  printf("Clair Event Loop Started (Ada Backend)...\n");

  /* Register Timer Source */
  clair_event_source_t* timer = clair_event_loop_add_timer(
      ctx.loop, 1000, on_timer_tick, false, &ctx);

  if (!timer)
  {
    fprintf (stderr, "Error: Failed to register timer (errno: %d, %s)\n",
              errno, strerror (errno));
    goto cleanup_loop;
  }

    /* Register I/O Watch Source (Stdin) */
    clair_event_source_t* watch = clair_event_loop_add_watch(
        ctx.loop, STDIN_FILENO, CLAIR_EVENT_INPUT, on_stdin_readable, NULL);

    if (!watch) {
        fprintf(stderr, "Error: Failed to register stdin watcher\n");
        /* Non-fatal: we can still continue with the timer */
    }

    printf ("Instructions: Type something to see it reflected, or wait 5s for auto-quit.\n");

    /* Main Execution */
    result = clair_event_loop_run(ctx.loop);
    if (result != 0) {
        fprintf(stderr, "Runtime Error: Loop exited with code %d\n", result);
    }

    /* Resource Cleanup */
    printf("\nCleaning up resources...\n");
    if (timer) clair_event_loop_remove(ctx.loop, timer);
    if (watch) clair_event_loop_remove(ctx.loop, watch);

cleanup_loop:
  clair_event_loop_destroy (ctx.loop);

cleanup_ada:
  /* Finalization: Ada Runtime Termination */
  printf ("Clair Shutdown Complete.\n");
  adafinal ();

  return (result == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}
